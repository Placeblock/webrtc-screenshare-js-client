import { createPeerControlElement, createPeerElement } from "./elements";
import Peer from "./peerdata";
import { getSettings, onSettingsUpdate } from "./settings";
import { State, setState } from "./state";
import { registerMessageHandler, sendMessage } from "./websocket";

const stopStreamButton = document.getElementById("stop-stream-btn");
const shareLinkButton = document.getElementById("share-link");
const peersControlsElement = document.getElementById("peers-controls-container");
const peersElement = document.getElementById("peers-container")
const clientStreamElement = document.getElementById("client-stream");
const noClientStreamElement = document.getElementById("no-client-stream");
clientStreamElement.onloadedmetadata = () => {
    clientStreamElement.play();
}

const downloadBitrateValue = document.getElementById("download-bitrate-value");
const uploadBitrateValue = document.getElementById("upload-bitrate-value");

var id;
var uuid;
var name;
var stream;
const peers = {};

function addPeer(p) {
    const peerControlElement = createPeerControlElement(p.name, () => {
        if (stream != null) {
            peer.startStreaming(stream, getSettings());
            return true;
        }
        return false;
    }, () => {
        peer.stopStreaming();
    });
    peersControlsElement.appendChild(peerControlElement);
    const peerElement = createPeerElement(p.name, (fullscreen) => {
        peer.setFullScreen(fullscreen);
    });
    peersElement.appendChild(peerElement);
    const peer = new Peer(p.uuid, p.name, 
        peerControlElement, peerElement, 
        () => checkAutoSend(peer), sendMessage, () => {
            peer.updateQuality(getSettings());
        });
    peers[p.uuid] = peer;
}

function checkAutoSend(peer) {
    const settings = getSettings();
    if (settings.autoShare && stream !== null) {
        peer.startStreaming(stream, settings);
    }
}

onSettingsUpdate(() => {
    const settings = getSettings();
    Object.values(peers).forEach((peer) => {
        peer.updateQuality(settings);
    })
})

function removePeer(uuid) {
    const peer = peers[uuid];
    if (peer === undefined) return;
    peer.remove();
}

stopStreamButton.onclick = () => {
    stopStream();
}

document.getElementById("select-stream-btn").onclick = () => {
    navigator.mediaDevices.getDisplayMedia({audio: true}).then(newstream => {
        stopStream();
        setStream(newstream);
    });
}

function stopStream() {
    Object.values(peers).forEach((peer) => {
        peer.stopStreaming();
    })
    if (stream != null) { 
        stream.getTracks().forEach(track => track.stop());
    }
    noClientStreamElement.classList.remove("hidden");
    clientStreamElement.classList.add("hidden");
    clientStreamElement.srcObject = null;
    stopStreamButton.classList.add("hidden");
    stream = null;
}

function setStream(newstream) {
    stream = newstream;
    noClientStreamElement.classList.add("hidden");
    clientStreamElement.classList.remove("hidden");
    clientStreamElement.srcObject = stream;
    Object.values(peers).forEach((peer) => {
        checkAutoSend(peer);
    })
    stopStreamButton.classList.remove("hidden");
}

shareLinkButton.onclick = () => {
    navigator.clipboard.writeText(window.location.href);
    shareLinkButton.innerText = "Copied to clipboard!";
    setTimeout(() => {
        shareLinkButton.innerText = "Invite others";
    }, 5000);
}

setInterval(() => {
    var sendingBitrate = 0;
    var receivingBitrate = 0;
    Object.values(peers).forEach(peer => {
        peer.updateBitrate();
        sendingBitrate+=peer.sendingBitRate;
        receivingBitrate+=peer.receivingBitRate;

        // Cleanup inactive transceivers
        console.log("Transceivers: "+ peer.connection.getTransceivers().length);
        peer.connection.getTransceivers().forEach(t => {
            console.log(t.currentDirection);
            if (t.currentDirection === "inactive") {
                t.stop();
            }
        });
    })
    downloadBitrateValue.innerText = receivingBitrate;
    uploadBitrateValue.innerText = sendingBitrate;
}, 1000);

registerMessageHandler("room", (data) => {
    id = data.room.id;
    uuid = data.uuid;
    name = data.name;
    data.room.users.forEach((user) => {
        if (user.uuid===uuid)return;
        addPeer(user);
    })
    window.history.replaceState(null, "", id)
    setState(State.ROOM);
})

registerMessageHandler("peer", (data) => {
    const peer = peers[data.sender];
    if (peer == undefined) return;
    peer.handlePeerMessage(data.message);
})

registerMessageHandler("add_users", (data) => {
    data.users.forEach((user) => {
        addPeer(user);
    })
})

registerMessageHandler("remove_user", (data) => {
    removePeer(data.user.uuid);
})